# 경복궁 시간의 놀이문 - VIVEN SDK 설계서

## 1. 프로젝트 개요

### 1.1 기본 정보
| 항목 | 내용 |
|------|------|
| **게임 제목** | 경복궁 시간의 놀이문 |
| **장르** | VR 인터랙티브 어드벤처 + 라운드 기반 스테이지 게임 |
| **플랫폼** | VIVEN VR (HMD + 컨트롤러) |
| **타깃** | 10~30대 체험형 콘텐츠 소비자 |
| **플레이 시간** | 7~10분 |

### 1.2 콘셉트
> "현대 경복궁에서 조선으로 타임리프되어, 도깨비가 내리는 두 가지 전통 놀이 시험을 통과해야 돌아갈 수 있는 VR 라운드 게임."

### 1.3 핵심 메커니즘
1. **발판 선택 메커니즘** (판돌 건너기) - Round 1
2. **정확도·힘 조절 투척** (비석치기) - Round 2

---

## 2. VIVEN SDK 아키텍처

### 2.1 씬 구조 (단일 씬 방식)

> **중요**: VIVEN SDK는 단일 씬 내에서 영역 전환 방식을 권장합니다.
> SceneManager.LoadScene 대신 오브젝트 활성화/비활성화 및 텔레포트를 사용합니다.

```
TraditionalGames (Single Scene)
├── Managers/
│   ├── GameFlowManager (전체 게임 흐름)
│   ├── StageManager (스테이지별 관리)
│   └── AudioManager (사운드)
├── Areas/
│   ├── Area_00_Prologue/    (시작 - 현대 경복궁)
│   ├── Area_01_Timeleap/    (타임리프 연출)
│   ├── Area_02_Pandol/      (Round 1: 판돌 건너기)
│   ├── Area_03_Biseok/      (Round 2: 비석치기)
│   └── Area_04_Ending/      (엔딩)
├── Player/
│   └── XR Origin (VIVEN 표준)
├── Characters/
│   └── Goblin (수문도깨비)
└── UI/
    ├── DialogCanvas
    └── ResultCanvas
```

### 2.2 게임 상태 머신

```lua
---@alias GameState "Prologue" | "Timeleap" | "Round1" | "Round2" | "Ending"

-- 상태 전이 (텔레포트 + 오브젝트 활성화 방식)
-- Prologue → Timeleap (보따리 트리거)
-- Timeleap → Round1 (도깨비 대사 완료)
-- Round1 → Round2 (판돌 클리어)
-- Round2 → Ending (비석치기 클리어)
-- Ending → Prologue (현대 복귀)
```

### 2.3 스테이지 전환 방식

```lua
-- VIVEN SDK 방식: 텔레포트 + FadeIn/FadeOut
function TransitionToStage(targetArea, spawnPoint)
    UI.FadeOut(1.0, function()
        -- 현재 영역 비활성화
        currentArea:SetActive(false)

        -- 타겟 영역 활성화
        targetArea:SetActive(true)

        -- 플레이어 텔레포트
        Player.Mine.TeleportPlayer(spawnPoint.position, spawnPoint.rotation)

        UI.FadeIn(1.0, nil)
    end)
end
```

---

## 3. 세계관 및 캐릭터

### 3.1 세계관
- **현대 경복궁**: 야간 개장 분위기, 바닥에 빛나는 전통 보따리
- **조선 경복궁**: 판타지화된 공간, 단청이 살아 움직이는 느낌
- **시간 시험**: 도깨비가 내리는 전통놀이 기반 시험

### 3.2 캐릭터

#### 수문도깨비 (Guardian Goblin)
| 속성 | 설명 |
|------|------|
| 역할 | 경복궁 시간을 지키는 수문장 |
| 성격 | 장난기 있으나 서늘한 분위기 |
| 비주얼 | 사람보다 약간 큰 실루엣, 뿔·탈 형상 |
| 등장 | 단청 파편이 모여 형성되는 연출 |

**대사 목록**:
- 타임리프: "경복궁의 시간을 지키기 위해 너에게 두 가지 시험을 내리겠다."
- 판돌: "첫 번째 시험이다. 눈에 보이는 길만이 정답은 아니다. 직감을 믿어 앞으로 나아가라."
- 비석치기: "마지막 시험이다. 너의 손끝에서 모든 것이 갈린다. 시간의 비석을 쓰러뜨려라!"
- 엔딩: "전통이 잊혀져 가는 것이 두려웠기 때문이다..."

---

## 4. 스테이지별 상세 설계

### 4.0 프롤로그 (Area_00_Prologue) - 현대 경복궁 [시작 영역]

#### 공간 구성
- 야간 경복궁 중앙 마당 (또는 낮)
- 바닥에 '전통 보따리' 오브젝트
- 보따리 주변 파티클 이펙트 (반짝임)

#### 오브젝트 구조
```
Area_00_Prologue/
├── Environment/
│   ├── GyeongbokgungModern (3D 모델)
│   └── Lighting
├── Bottari (보따리)
│   ├── BottariMesh
│   ├── SparkleParticle
│   └── TriggerZone (Collider, Is Trigger)
├── SpawnPoint
└── NarrationAudio
```

#### Lua 스크립트

**BottariTrigger.lua** (구현 완료)

> **변경사항**: 자동 카운트다운 방식으로 변경, VR 컨트롤러 이름 기반 감지

```lua
---보따리 트리거 스크립트
---@description 프롤로그에서 보따리 상호작용 처리 (자동 카운트다운)

--region Injection
local _INJECTED_ORDER = 0
local function NullableInject(OBJECT)
    _INJECTED_ORDER = _INJECTED_ORDER + 1
    if OBJECT == nil then
        Debug.Log(_INJECTED_ORDER .. "th object is missing (nullable)")
    end
    return OBJECT
end

---@type string
gameFlowManagerName = NullableInject(gameFlowManagerName) or "GameFlowManager"

---@type GameObject
---@details "열기" 안내 UI 오브젝트 (TMP_Text 포함)
openUIObject = NullableInject(openUIObject)

---@type number
---@details 카운트다운 시작 숫자 (기본값: 5)
countdownStart = NullableInject(countdownStart) or 5
--endregion

--region Variables
local util = require 'xlua.util'
local TMP_Text = typeof(CS.TMPro.TMP_Text)

local gameFlowManager = nil
local isPlayerNear = false
local hasTriggered = false
local countdownText = nil
--endregion

function awake()
    gameFlowManager = self:GetLuaComponentInParent(gameFlowManagerName)

    -- TMP_Text 컴포넌트 가져오기
    if openUIObject then
        countdownText = openUIObject:GetComponentInChildren(TMP_Text)
    end
end

-- VR 컨트롤러/손 감지 (이름 기반)
function onTriggerEnter(other)
    if hasTriggered then return end

    local isPlayerHand = string.find(other.name, "Grabber") ~= nil
        or string.find(other.name, "Placer") ~= nil
        or string.find(other.name, "Interactor") ~= nil
        or string.find(other.name, "Hand") ~= nil
        or other.name == "CharacterController"
        or other.tag == "Player"

    if isPlayerHand then
        isPlayerNear = true
        StartCountdown()  -- 자동 카운트다운 시작
    end
end

-- 카운트다운 후 자동 전환
function StartCountdown()
    if hasTriggered then return end
    hasTriggered = true

    self:StartCoroutine(util.cs_generator(function()
        if openUIObject then openUIObject:SetActive(true) end

        for i = countdownStart, 1, -1 do
            if countdownText then countdownText.text = tostring(i) end
            coroutine.yield(WaitForSeconds(1.0))
        end

        if openUIObject then openUIObject:SetActive(false) end
        OnOpenBottari()
    end))
end

function OnOpenBottari()
    -- 타임리프로 전환
    if gameFlowManager then
        gameFlowManager.TransitionToTimeleap()
    end
end
```

---

### 4.1 타임리프 (Area_01_Timeleap)

#### 연출 플로우
1. 화면 주변 어두워짐 + 단청 문양 확대 애니메이션
2. 종소리 + 바람소리
3. 수문도깨비 실루엣 등장
4. 도깨비 대사 → Round 1 (판돌 건너기)로 전환

#### VIVEN 구현
```lua
-- TimeleapManager.lua
function StartTimeleapSequence()
    self:StartCoroutine(util.cs_generator(function()
        -- 1. 환경 연출 (스카이박스 변경, 단청 파티클)
        PlayDanchengEffect()
        coroutine.yield(WaitForSeconds(2.0))

        -- 2. 사운드 연출
        bellSound:Play()
        windSound:Play()
        coroutine.yield(WaitForSeconds(1.5))

        -- 3. 도깨비 등장
        goblinObject:SetActive(true)
        PlayGoblinAppearEffect()
        coroutine.yield(WaitForSeconds(1.0))

        -- 4. 도깨비 대사 재생
        goblinVoice:Play()  -- "경복궁의 시간을 지키기 위해..."
        ShowSubtitle("경복궁의 시간을 지키기 위해\n너에게 두 가지 시험을 내리겠다.")
        coroutine.yield(WaitForSeconds(5.0))

        -- 5. Round 1 (판돌 건너기)로 전환
        gameFlowManager.TransitionToRound1()
    end))
end
```

---

### 4.2 ROUND 1: 판돌 건너기 (Area_02_Pandol)

#### 레벨 구조
- 공중에 길게 이어진 돌다리
- 두 줄 발판 (좌/우)
- 한 발판은 "안전", 하나는 "깨짐"
- 총 10~12단계

#### 오브젝트 구조
```
Area_02_Pandol/
├── Environment/
│   ├── Sky (높은 곳 배경)
│   └── FallZone (낙하 감지)
├── Platforms/
│   ├── StartPlatform
│   ├── StepPairs/ (10~12개 단계)
│   │   ├── Step_01_Left
│   │   ├── Step_01_Right
│   │   └── ...
│   └── GoalPlatform
├── Goblin (도깨비 - 힌트 대사)
├── SpawnPoint
└── UI/
    └── HintUI
```

#### 핵심 시스템: 발판 생성 및 물리

**PandolManager.lua**
```lua
---판돌 건너기 게임 매니저

--region Injection
local _INJECTED_ORDER = 0
local function checkInject(OBJECT)
    _INJECTED_ORDER = _INJECTED_ORDER + 1
    assert(OBJECT, _INJECTED_ORDER .. "th object is missing")
    return OBJECT
end

---@type GameObject
safePlatformPrefab = checkInject(safePlatformPrefab)

---@type GameObject
breakingPlatformPrefab = checkInject(breakingPlatformPrefab)

---@type Transform
platformStartPoint = checkInject(platformStartPoint)

---@type Transform
spawnPoint = checkInject(spawnPoint)

---@type GameObject
goalZone = checkInject(goalZone)

---@type number
stepCount = checkInject(stepCount) or 10

---@type number
stepDistance = checkInject(stepDistance) or 1.5

---@type number
pairWidth = checkInject(pairWidth) or 1.0

---@type number
fallThreshold = checkInject(fallThreshold) or -10

---@type AudioClip
glassBreakSound = checkInject(glassBreakSound)

---@type string
gameFlowManagerName = checkInject(gameFlowManagerName)
--endregion

--region Variables
local util = require 'xlua.util'
local gameFlowManager = nil
local platforms = {}
local isGameActive = false
--endregion

function awake()
    gameFlowManager = self:GetLuaComponentInParent(gameFlowManagerName)
end

function StartGame()
    if isGameActive then return end

    isGameActive = true

    -- 기존 발판 제거
    ClearPlatforms()

    -- 발판 생성
    GeneratePlatforms()

    -- 도깨비 힌트 대사 재생
    PlayGoblinHint()
end

function GeneratePlatforms()
    for i = 1, stepCount do
        local zOffset = i * stepDistance
        local basePosition = platformStartPoint.position + Vector3(0, 0, zOffset)

        -- 랜덤으로 안전/깨짐 결정
        local safeIsLeft = math.random() > 0.5

        -- 왼쪽 발판
        local leftPos = basePosition + Vector3(-pairWidth / 2, 0, 0)
        local leftPrefab = safeIsLeft and safePlatformPrefab or breakingPlatformPrefab
        local leftPlatform = GameObject.Instantiate(leftPrefab)
        leftPlatform.transform.position = leftPos
        leftPlatform.name = "Step_" .. i .. "_Left"

        -- 왼쪽 발판 스크립트 설정
        local leftScript = leftPlatform:GetLuaComponent("PlatformStep")
        if leftScript then
            leftScript.SetManager(self)
            leftScript.SetIsSafe(safeIsLeft)
        end

        -- 오른쪽 발판
        local rightPos = basePosition + Vector3(pairWidth / 2, 0, 0)
        local rightPrefab = safeIsLeft and breakingPlatformPrefab or safePlatformPrefab
        local rightPlatform = GameObject.Instantiate(rightPrefab)
        rightPlatform.transform.position = rightPos
        rightPlatform.name = "Step_" .. i .. "_Right"

        -- 오른쪽 발판 스크립트 설정
        local rightScript = rightPlatform:GetLuaComponent("PlatformStep")
        if rightScript then
            rightScript.SetManager(self)
            rightScript.SetIsSafe(not safeIsLeft)
        end

        table.insert(platforms, leftPlatform)
        table.insert(platforms, rightPlatform)
    end
end

function ClearPlatforms()
    for _, platform in ipairs(platforms) do
        if platform then
            GameObject.Destroy(platform)
        end
    end
    platforms = {}
end

function update()
    if not isGameActive then return end

    -- 낙하 감지
    local playerY = Player.Mine.HeadTransform.position.y
    if playerY < fallThreshold then
        OnPlayerFall()
    end
end

function OnPlayerFall()
    -- 낙하 처리
    self:StartCoroutine(util.cs_generator(function()
        coroutine.yield(WaitForSeconds(0.5))

        UI.FadeOut(1.0, function()
            -- 시작 지점으로 리스폰
            Player.Mine.TeleportPlayer(spawnPoint.position, spawnPoint.rotation)

            UI.FadeIn(1.0, nil)
        end)
    end))
end

function OnPlatformBreak(platform)
    -- 깨지는 발판 효과
    AudioSource.PlayClipAtPoint(glassBreakSound, platform.transform.position)

    -- 메쉬 비활성화 + 파티클 (또는 Collider 비활성화)
    local meshRenderer = platform:GetComponent(typeof(MeshRenderer))
    if meshRenderer then
        meshRenderer.enabled = false
    end

    local collider = platform:GetComponent(typeof(Collider))
    if collider then
        collider.enabled = false
    end

    -- 깨지는 파티클 재생
    local breakEffect = platform:GetComponentInChildren(typeof(ParticleSystem))
    if breakEffect then
        breakEffect:Play()
    end
end

function OnGoalReached()
    if not isGameActive then return end

    isGameActive = false

    self:StartCoroutine(util.cs_generator(function()
        UI.ToastMessage("통과!")
        coroutine.yield(WaitForSeconds(2.0))

        gameFlowManager.TransitionToRound2()
    end))
end

function PlayGoblinHint()
    -- "눈에 보이는 길만이 정답은 아니다. 직감을 믿어라" 재생
end
```

**PlatformStep.lua**
```lua
---발판 스크립트

--region Variables
local manager = nil
local isSafe = true
local hasTriggered = false
--endregion

function SetManager(mgr)
    manager = mgr
end

function SetIsSafe(safe)
    isSafe = safe
end

function onCollisionEnter(collision)
    if hasTriggered then return end

    if collision.gameObject.tag == "Player" then
        hasTriggered = true

        if not isSafe then
            -- 깨지는 발판
            manager.OnPlatformBreak(self.gameObject)
        end
    end
end
```

**GoalZoneTrigger.lua**
```lua
---골 영역 트리거

--region Injection
local _INJECTED_ORDER = 0
local function checkInject(OBJECT)
    _INJECTED_ORDER = _INJECTED_ORDER + 1
    assert(OBJECT, _INJECTED_ORDER .. "th object is missing")
    return OBJECT
end

---@type string
managerName = checkInject(managerName)
--endregion

--region Variables
local manager = nil
--endregion

function awake()
    manager = self:GetLuaComponentInParent(managerName)
end

function onTriggerEnter(other)
    if other.gameObject.tag == "Player" then
        manager.OnGoalReached()
    end
end
```

---

### 4.3 ROUND 2: 비석치기 (Area_03_Biseok)

#### 레벨 구조
- 근정전 앞 넓은 광장
- 전방 5~10m에 대형 비석 3개
- 일정 거리에서 투척 위치 고정

#### 오브젝트 구조
```
Area_03_Biseok/
├── Environment/
│   └── GeunjeongjeonSquare
├── Biseok/ (비석 3개)
│   ├── Biseok_01
│   ├── Biseok_02
│   └── Biseok_03
├── ThrowingStone (던지는 돌)
│   ├── VObject
│   ├── VivenGrabbableModule
│   ├── VivenRigidbodyControlModule
│   └── VivenGrabbableRigidView
├── StoneSpawnPoint
├── ThrowingLine
├── Goblin (도깨비 - 힌트 대사)
├── SpawnPoint
└── UI/
    └── AttemptCountUI
```

#### 핵심 시스템: 투척 + 비석 쓰러짐

**BiseokManager.lua**
```lua
---비석치기 게임 매니저

--region Injection
local _INJECTED_ORDER = 0
local function checkInject(OBJECT)
    _INJECTED_ORDER = _INJECTED_ORDER + 1
    assert(OBJECT, _INJECTED_ORDER .. "th object is missing")
    return OBJECT
end

---@type GameObject
stonePrefab = checkInject(stonePrefab)

---@type Transform
stoneSpawnPoint = checkInject(stoneSpawnPoint)

---@type GameObject[]
biseokObjects = checkInject(biseokObjects)

---@type number
---@details 클리어에 필요한 쓰러뜨린 비석 수
requiredKnockdown = checkInject(requiredKnockdown) or 2

---@type number
---@details 비석 쓰러짐 판정 각도
knockdownAngle = checkInject(knockdownAngle) or 60

---@type number
---@details 최대 시도 횟수
maxAttempts = checkInject(maxAttempts) or 5

---@type string
gameFlowManagerName = checkInject(gameFlowManagerName)
--endregion

--region Variables
local util = require 'xlua.util'
local gameFlowManager = nil
local currentStone = nil
local knockedBiseokCount = 0
local attemptCount = 0
local biseokStates = {}  -- 각 비석의 쓰러짐 상태
local isGameActive = false
--endregion

function awake()
    gameFlowManager = self:GetLuaComponentInParent(gameFlowManagerName)

    -- 비석 상태 초기화
    for i, biseok in ipairs(biseokObjects) do
        biseokStates[i] = false
    end
end

function StartGame()
    if isGameActive then return end

    isGameActive = true
    knockedBiseokCount = 0
    attemptCount = 0

    -- 첫 번째 돌 생성
    SpawnStone()

    -- 도깨비 대사 재생
    PlayGoblinHint()
end

function SpawnStone()
    if currentStone then
        GameObject.Destroy(currentStone)
    end

    currentStone = GameObject.Instantiate(stonePrefab)
    currentStone.transform.position = stoneSpawnPoint.position
    currentStone.transform.rotation = stoneSpawnPoint.rotation

    -- 돌 스크립트 설정
    local stoneScript = currentStone:GetLuaComponent("ThrowingStone")
    if stoneScript then
        stoneScript.SetManager(self)
    end
end

function update()
    if not isGameActive then return end

    -- 비석 쓰러짐 체크
    CheckBiseokStates()
end

function CheckBiseokStates()
    for i, biseok in ipairs(biseokObjects) do
        if not biseokStates[i] then
            local angle = Vector3.Angle(biseok.transform.up, Vector3.up)
            if angle > knockdownAngle then
                biseokStates[i] = true
                knockedBiseokCount = knockedBiseokCount + 1
                OnBiseokKnocked(i)
            end
        end
    end
end

function OnBiseokKnocked(index)
    Debug.Log("비석 " .. index .. " 쓰러짐! 총: " .. knockedBiseokCount)

    -- 클리어 체크
    if knockedBiseokCount >= requiredKnockdown then
        OnGameClear()
    end
end

function OnStoneThrown()
    attemptCount = attemptCount + 1

    -- 돌이 던져진 후 일정 시간 후 새 돌 생성
    self:StartCoroutine(util.cs_generator(function()
        coroutine.yield(WaitForSeconds(2.0))

        if isGameActive then
            -- 시도 횟수 체크
            if attemptCount >= maxAttempts and knockedBiseokCount < requiredKnockdown then
                -- 실패 처리 (재시작)
                OnGameFail()
            else
                SpawnStone()
            end
        end
    end))
end

function OnGameClear()
    isGameActive = false

    self:StartCoroutine(util.cs_generator(function()
        UI.ToastMessage("성공!")
        coroutine.yield(WaitForSeconds(2.0))

        gameFlowManager.TransitionToEnding()
    end))
end

function OnGameFail()
    isGameActive = false

    self:StartCoroutine(util.cs_generator(function()
        UI.ToastMessage("다시 도전!")
        coroutine.yield(WaitForSeconds(1.5))

        -- 비석 상태 리셋
        ResetBiseoks()

        -- 게임 재시작
        StartGame()
    end))
end

function ResetBiseoks()
    for i, biseok in ipairs(biseokObjects) do
        biseokStates[i] = false
        -- 비석 원래 위치/회전으로 복원
        -- (필요시 초기 Transform 저장 후 복원)
    end
    knockedBiseokCount = 0
end

function PlayGoblinHint()
    -- "마지막 시험이다. 너의 손끝에서 모든 것이 갈린다" 재생
end
```

**ThrowingStone.lua**
```lua
---던지는 돌 스크립트 (VIVEN Grabbable 기반)

--region Injection
local _INJECTED_ORDER = 0
local function checkInject(OBJECT)
    _INJECTED_ORDER = _INJECTED_ORDER + 1
    assert(OBJECT, _INJECTED_ORDER .. "th object is missing")
    return OBJECT
end

---@type string
gameManagerName = checkInject(gameManagerName)
--endregion

--region Variables
local util = require 'xlua.util'
XRHandAPI = CS.TwentyOz.VivenSDK.ExperimentExtension.Scripts.API.Experiment.XRHandAPI
Handedness = CS.TwentyOz.VivenSDK.Scripts.Core.Haptic.DataModels.SDKHandedness
FingerType = CS.TwentyOz.VivenSDK.Scripts.Core.Haptic.DataModels.SDKFingerType

local gameManager = nil
local grabbableModule = nil
local rigidbodyModule = nil
local isGrabbed = false
local isThrown = false
local minThrowVelocity = 2.0
--endregion

function awake()
    grabbableModule = self:GetComponent("VivenGrabbableModule")
    rigidbodyModule = self:GetComponent("VivenRigidbodyControlModule")
end

function SetManager(mgr)
    gameManager = mgr
end

function start()
    local rigidBody = rigidbodyModule.Rigid
    rigidBody.collisionDetectionMode = CS.UnityEngine.CollisionDetectionMode.ContinuousDynamic
end

function onGrab()
    isGrabbed = true
    isThrown = false

    -- 햅틱 피드백
    PlayHapticFeedback(0.3, 0.1)
end

function onRelease()
    isGrabbed = false

    -- 던진 속도 체크
    local velocity = rigidbodyModule.Rigid.velocity.magnitude
    if velocity > minThrowVelocity then
        isThrown = true

        if gameManager then
            gameManager.OnStoneThrown()
        end
    end
end

function onCollisionEnter(collision)
    if isThrown then
        -- 비석과 충돌 시 햅틱
        if collision.gameObject.tag == "Biseok" then
            PlayHapticFeedback(0.6, 0.2)
        end
    end
end

function PlayHapticFeedback(intensity, duration)
    if XRHandAPI.GetHandTrackingMode() == "None" then
        XR.StartControllerVibration(false, intensity, duration)
    else
        HandTracking.CommandVibrationHaptic(intensity * 0.3, duration * 1000, Handedness.Right, FingerType.Index, false)
    end
end
```

---

### 4.4 엔딩 (Area_04_Ending)

#### 연출 플로우
1. 비석 클리어 → 빛 기둥 생성
2. '시간문' 열림
3. 도깨비 등장 → 마지막 메시지
4. '전통놀이 계승자 배지' 지급
5. 현대 경복궁으로 복귀

#### VIVEN 구현
```lua
-- EndingManager.lua
function StartEndingSequence()
    self:StartCoroutine(util.cs_generator(function()
        -- 1. 클리어 연출 (빛 기둥)
        lightPillarEffect:SetActive(true)
        coroutine.yield(WaitForSeconds(2.0))

        -- 2. 시간문 열림
        timeGateAnimator:SetTrigger("Open")
        coroutine.yield(WaitForSeconds(1.5))

        -- 3. 도깨비 등장 + 마지막 대사
        goblinObject:SetActive(true)
        goblinVoice:Play()  -- "전통이 잊혀져 가는 것이..."
        ShowSubtitle("전통이 잊혀져 가는 것이 두려웠기 때문이다.\n놀이에는 우리의 시간과 마음이 이어져 있다.")
        coroutine.yield(WaitForSeconds(6.0))

        -- 4. 배지 지급
        badgeObject:SetActive(true)
        badgeAnimator:SetTrigger("Appear")
        ShowSubtitle("전통놀이 계승자 배지 획득!")
        coroutine.yield(WaitForSeconds(3.0))

        -- 5. 현대 복귀
        UI.FadeOut(2.0, function()
            -- 현대 경복궁으로 텔레포트 (보따리 닫힌 상태)
            TransitionToModernGyeongbokgung()

            UI.FadeIn(2.0, function()
                ShowSubtitle("당신의 시간, 돌아왔습니다.")
            end)
        end)
    end))
end
```

---

## 5. 게임 플로우 요약

```
[프롤로그 - 현대 경복궁] ← 시작
    │ 보따리 열기
    ▼
[타임리프 연출]
    │ 도깨비: "두 가지 시험을 내리겠다"
    ▼
[Round 1: 판돌 건너기]
    │ 클리어
    ▼
[Round 2: 비석치기]
    │ 클리어
    ▼
[엔딩]
    │ 도깨비 인사 + 배지 지급
    ▼
[현대 경복궁으로 복귀 (프롤로그)]
```

---

## 6. 제외된 기능 (VIVEN 미지원 또는 불필요)

### 6.1 제외 목록

| 원본 기능 | 제외 이유 | 대체 방안 |
|-----------|-----------|-----------|
| 무궁화 꽃이 피었습니다 | 개발 기간 단축 | 제외 |
| SceneManager.LoadScene | VIVEN 단일 씬 권장 | 영역 활성화/비활성화 + 텔레포트 |
| 레이캐스트 UI 상호작용 | VIVEN 직접 상호작용 방식 | 트리거 영역 + 버튼 입력 |
| AsyncOperation | 단일 씬이므로 불필요 | 오브젝트 풀링 |
| 파워 게이지 Hold UI | 복잡한 UI 구현 | 던지기 속도 기반 자연스러운 투척 |
| 비석 HP 시스템 | 과도한 복잡성 | 각도 기반 쓰러짐 판정 |

### 6.2 단순화된 구현

**비석치기 투척 방식**:
- VIVEN Grabbable로 직접 잡아서 던지기 (자연스러운 VR 경험)

**발판 파괴 효과**:
- Collider 비활성화 + 메쉬 투명화 (또는 단순 파티클)

---

## 7. 사운드 설계

### 7.1 BGM
| 씬 | BGM | 설명 |
|-----|-----|------|
| 프롤로그 | 잔잔한 야간 경복궁 앰비언트 | 현실적 분위기 |
| 타임리프 | 왜곡된 바람 + 단청 깨지는 소리 | 긴장감 |
| 라운드 1~2 | 긴장감 있는 국악 | 전통 + 다크 판타지 |
| 엔딩 | 은은한 해금 | 따뜻한 마무리 |

### 7.2 SFX
| 효과음 | 사용처 |
|--------|--------|
| 종소리 | 타임리프 |
| 바람소리 | 타임리프, 판돌 |
| 유리 깨지는 소리 | 판돌 깨짐 |
| 돌 충돌음 | 비석치기 |
| 성공/실패 차임 | 라운드 클리어/탈락 |

---

## 8. 기술 요구사항

### 8.1 VIVEN SDK 컴포넌트
- VObject (모든 동기화 오브젝트)
- VivenGrabbableModule (던지는 돌)
- VivenRigidbodyControlModule (물리 오브젝트)
- VivenGrabbableRigidView (네트워크 동기화)
- VivenLuaBehaviour (모든 스크립트)
- VivenTransformView (위치 동기화)

### 8.2 VIVEN SDK Lua 주의사항

#### 디버그 로깅
```lua
-- ❌ 사용 불가 (VIVEN SDK 미지원)
Debug.LogWarning("warning message")
Debug.LogError("error message")

-- ✅ 대신 사용
Debug.Log("[ScriptName] WARNING: message")
Debug.Log("[ScriptName] ERROR: message")
```

#### 의존성 주입 패턴
```lua
-- 필수 변수 (없으면 에러)
local function checkInject(OBJECT)
    _INJECTED_ORDER = _INJECTED_ORDER + 1
    assert(OBJECT, _INJECTED_ORDER .. "th object is missing")
    return OBJECT
end

-- 선택적 변수 (없어도 동작)
local function NullableInject(OBJECT)
    _INJECTED_ORDER = _INJECTED_ORDER + 1
    if OBJECT == nil then
        Debug.Log(_INJECTED_ORDER .. "th object is missing (nullable)")
    end
    return OBJECT
end

-- 기본값 설정
gameFlowManagerName = NullableInject(gameFlowManagerName) or "GameFlowManager"
```

#### Transform 주입 패턴
```lua
-- Inspector에서 GameObject 연결
---@type GameObject
spawnPointObject = NullableInject(spawnPointObject)

-- awake()에서 Transform 추출
function awake()
    if spawnPointObject then
        spawnPoint = spawnPointObject.transform
    end
end
```

#### TMP_Text 접근 패턴
```lua
-- 타입 정의
local TMP_Text = typeof(CS.TMPro.TMP_Text)

-- Inspector에서 GameObject 연결 (TMP_Text 포함)
---@type GameObject
textObject = NullableInject(textObject)

-- awake()에서 컴포넌트 가져오기
function awake()
    if textObject then
        tmpText = textObject:GetComponentInChildren(TMP_Text)
    end
end
```

#### VR 컨트롤러/손 감지
```lua
-- Player 태그 대신 이름 기반 감지
function onTriggerEnter(other)
    local isPlayerHand = string.find(other.name, "Grabber") ~= nil
        or string.find(other.name, "Placer") ~= nil
        or string.find(other.name, "Interactor") ~= nil
        or string.find(other.name, "Hand") ~= nil
        or other.name == "CharacterController"
        or other.tag == "Player"

    if isPlayerHand then
        -- 플레이어 감지됨
    end
end
```

### 8.3 최적화 지침
- 오브젝트 수 최소화
- 그림자 품질 중간
- 발판 파괴는 Collider Off 방식
- 비석 물리는 단순 회전/기울기 애니메이션

### 8.4 성능 목표
- 프레임레이트: 72fps 이상
- 로딩 시간: 초기 5초 이내
- 메모리: 2GB 이하
